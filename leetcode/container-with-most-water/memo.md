考え
スタート位置を一番左において、そこから右に走査していく。
全探索では比較的かんたんに記述できるが、それを行うと計算量がO(n^2)となり爆発する。
```sh
配列全体のループと、配列内でのスタート位置を操作していくループの2つあるタイプが
O(n^2)であり、基本的に後者のループをO（1）にしてゆくのが比較的簡単な問題（medium程度？）
の解放なのだと思う。
前者のループと後者のループ2つに命名をしたい。もしかして既存かもだけどね。
```
unordered_map を使用したハッシュ検索をし、一回のループをO(1)にすることにより
全体的なループをO(n)にする手が考えられる。
全探索の内部ループをunordered_mapにする方法でいいかなあ。
それ以外に一般的な方法があるのか。
と思ったが、今回は答えに
```sh
互いの要素までの距離 * 高さの最大値
```
の2つの変数があるため、単純に1変数とそのインデントしか管理出来ないunorder_mapは適さないのではないか。
けどインデントも管理できるのであれば、インデントの差で別の要素に格納することはできるのかなと思ったけど、それだと
```sh
互いの要素までの距離（互いのインデントの差）
高さの最大値
```
を格納するために二回ループを回さなくてはならないので、結局O(n^2)になってしまう。
```sh
全体のループと、右側に操作していくループで全通りの変数をunordered_mapに格納していく必要あり
```
よって今回のケースでは使えないであろう。


